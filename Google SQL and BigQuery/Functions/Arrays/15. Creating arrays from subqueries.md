# üöÄ Creating Arrays from Subqueries in BigQuery

> **Reference:** [BigQuery Arrays Documentation](https://cloud.google.com/bigquery/docs/arrays#creating_arrays_from_subqueries)

## üìã Overview

Working with arrays in SQL can feel tricky at first, but GoogleSQL makes it elegant with the `ARRAY()` function. When working in BigQuery, you'll often need to convert the results of a subquery into an array format.

The `ARRAY()` function is one of the most powerful features in BigQuery's SQL dialect, enabling you to handle nested, repeated, or multi-valued data directly in SQL without flattening it.

## üéØ Learning Objectives

By the end of this guide, you'll understand:
- How to use the `ARRAY()` function with subqueries
- When and why to use this pattern
- Real-world applications in data engineering
- Best practices for array transformations

## üß© What is the ARRAY() Function?

### Syntax
```sql
ARRAY(subquery)
```

### Description
The `ARRAY()` function runs a subquery and returns its results as an array. Instead of getting multiple rows as output, you get a single array value containing all those rows.

### Key Concept: ARRAY() vs UNNEST()

| Function | Action | Direction |
|----------|--------|-----------|
| `UNNEST()` | Expands an array into rows | Array ‚Üí Rows |
| `ARRAY()` | Compresses rows into an array | Rows ‚Üí Array |

> **üí° Pro Tip:** Think of `UNNEST()` and `ARRAY()` as mirror functions - they perform opposite operations!

---

## üß† Why Use ARRAY() with Subqueries?

BigQuery excels at handling nested data structures. When you have arrays in your data (like order items, tags, or sensor readings), you often need to:

### Common Use Cases
- ‚úÖ **Transform** each element in an array
- ‚úÖ **Filter** specific elements based on conditions  
- ‚úÖ **Calculate** new values per element
- ‚úÖ **Maintain** the original array structure

### The Transformation Pattern
```
Original Array ‚Üí UNNEST() ‚Üí Transform/Filter ‚Üí ARRAY() ‚Üí New Array
```

This pattern allows you to perform complex manipulations while preserving the nested data structure that makes BigQuery so powerful.

---

## üíª Practical Example: Employee Project Analysis

Let's work through a complete example where we transform array data. We have employees with project IDs, and we want to extract only even project IDs and multiply them by 10.

### Step 1: Create the Table
```sql
CREATE TABLE Employees (
  name STRING,
  project_ids ARRAY<INT64>
);
```

### Step 2: Insert Sample Data
```sql
INSERT INTO Employees (name, project_ids) VALUES
('Alice', [101, 102, 103, 104]),
('Bob', [201, 202, 203]),
('Charlie', [301, 302]);
```

### Step 3: Transform with ARRAY() and Subquery
```sql
SELECT
  name,
  project_ids,
  ARRAY(
    SELECT pid * 10
    FROM UNNEST(project_ids) AS pid
    WHERE MOD(pid, 2) = 0  -- Filter for even numbers only
  ) AS even_project_units
FROM Employees;
```

### Results
| name    | project_ids          | even_project_units |
|---------|----------------------|--------------------|
| Alice   | [101, 102, 103, 104] | [1020, 1040]       |
| Bob     | [201, 202, 203]      | [2020]             |
| Charlie | [301, 302]           | [3020]             |

### üîç How It Works
1. **`UNNEST(project_ids)`** ‚Üí Expands the array into individual rows
2. **`WHERE MOD(pid, 2) = 0`** ‚Üí Filters for even project IDs only  
3. **`pid * 10`** ‚Üí Transforms each value by multiplying by 10
4. **`ARRAY(...)`** ‚Üí Reassembles the filtered and transformed rows back into a new array

---

## üìä Common Use Cases

### Array Transformation Patterns

| Use Case | Example | Pattern |
|----------|---------|---------|
| **Transform values** | Multiply or normalize each element | `ARRAY(SELECT expr FROM UNNEST(arr))` |
| **Filter arrays** | Keep only values matching a condition | `ARRAY(SELECT value FROM UNNEST(arr) WHERE condition)` |
| **Build from other tables** | Collect related rows into a single array | Use with `ARRAY_AGG()` |
| **Nested computations** | Create arrays of derived metrics | Combine with calculations |

### When to Use This Pattern

‚úÖ **Use ARRAY(subquery) when:**
- You need to create or modify arrays dynamically
- Performing element-wise transformations on existing arrays
- Building nested data structures for JSON output
- Aggregating related data into array format

‚ùå **Avoid when:**
- Simple array aggregation is sufficient (`ARRAY_AGG()` might be better)
- Working with flat data that doesn't benefit from nesting
- Performance is critical and simpler alternatives exist

---

## üè™ Real-World Example: Retail Order Analysis

Let's build a customer-friendly order summary where each order contains arrays of items, prices, and totals.

### Setup: Create Sample Tables
```sql
-- Orders table
CREATE TABLE Orders (
  order_id INT64,
  customer_name STRING
);

INSERT INTO Orders (order_id, customer_name) VALUES
(1001, 'Alice'),
(1002, 'Bob'),
(1003, 'Charlie');

-- OrderItems table  
CREATE TABLE OrderItems (
  order_id INT64,
  item STRING,
  price FLOAT64,
  quantity INT64
);

INSERT INTO OrderItems (order_id, item, price, quantity) VALUES
(1001, 'Laptop', 1200.00, 1),
(1001, 'Mouse', 25.00, 2),
(1002, 'Monitor', 300.00, 1),
(1002, 'Keyboard', 80.00, 1),
(1003, 'Desk', 200.00, 1),
(1003, 'Chair', 150.00, 2);
```

### Query: Aggregate Items into Arrays
```sql
SELECT
  o.order_id,
  o.customer_name,
  ARRAY_AGG(oi.item) AS items,
  ARRAY_AGG(oi.price) AS prices,
  ARRAY(
    SELECT price * quantity
    FROM UNNEST(ARRAY_AGG(STRUCT(oi.price, oi.quantity))) AS item_data
  ) AS item_totals
FROM Orders o
JOIN OrderItems oi ON o.order_id = oi.order_id
GROUP BY o.order_id, o.customer_name;
```

### Results
| order_id | customer_name | items                   | prices     | item_totals |
|----------|---------------|-------------------------|------------|-------------|
| 1001     | Alice         | ["Laptop", "Mouse"]     | [1200, 25] | [1200, 50]  |
| 1002     | Bob           | ["Monitor", "Keyboard"] | [300, 80]  | [300, 80]   |
| 1003     | Charlie       | ["Desk", "Chair"]       | [200, 150] | [200, 300]  |

### üîç Advanced Technique Breakdown
1. **`ARRAY_AGG(oi.item)`** ‚Üí Collects all item names into an array per order
2. **`ARRAY_AGG(oi.price)`** ‚Üí Collects all prices into an array per order
3. **`STRUCT(oi.price, oi.quantity)`** ‚Üí Groups price and quantity together
4. **`ARRAY_AGG(STRUCT(...))`** ‚Üí Creates array of structs for calculations
5. **`UNNEST(...) AS item_data`** ‚Üí Expands structs back into rows for computation
6. **`ARRAY(SELECT price * quantity ...)`** ‚Üí Computes totals and creates final array

---

## üîß Function Reference Summary

| Function | Purpose | When to Use |
|----------|---------|-------------|
| `ARRAY(subquery)` | Turn subquery results into an array | Dynamic array creation and transformation |
| `ARRAY_AGG(expr)` | Aggregate multiple rows into an array | Simple aggregation of column values |
| `UNNEST(array)` | Expand an array into rows | When you need to process array elements individually |
| `STRUCT()` | Group multiple columns together | Creating complex nested structures |

---

## üéØ Key Takeaways

### Core Concepts
- **`ARRAY(subquery)`** converts subquery results into array format
- **Perfect companion** to `UNNEST()` for array transformations  
- **Enables complex transformations** directly in SQL without external processing
- **Preserves nested structure** while allowing element-level operations

### Best Practices
1. **Combine with UNNEST()** for powerful array transformation patterns
2. **Use filtering and calculations** inside the subquery for precise control
3. **Consider performance** - complex nested operations can be expensive
4. **Test with sample data** to verify expected array structures

### Real-World Applications
- **API response building** - Create nested JSON structures
- **Analytics aggregation** - Pre-compute array-based metrics  
- **Data transformation** - Convert relational data to nested formats
- **ML feature engineering** - Build array features for machine learning


**Tags:** `#GoogleSQL` `#BigQuery` `#Arrays` `#DataEngineering` `#Analytics` `#SQL`
