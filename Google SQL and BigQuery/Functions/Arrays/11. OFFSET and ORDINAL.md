### ğŸ’¡ **Understanding OFFSET vs ORDINAL in BigQuery Arrays**

If youâ€™ve ever worked with **arrays in BigQuery**, youâ€™ve probably seen these two functions:
`OFFSET()` and `ORDINAL()`.
They look similar â€” but thereâ€™s a subtle difference that can trip you up! âš¡

ğŸ‘©â€ğŸ’» **Hereâ€™s the key:**

* **`OFFSET(n)`** â†’ starts counting from **0**
* **`ORDINAL(n)`** â†’ starts counting from **1**

âœ… **Example:**

```sql
SELECT
  my_array[OFFSET(0)] AS first_element_offset,
  my_array[ORDINAL(1)] AS first_element_ordinal
FROM my_table;
```

Both lines return the same element â€” the first one in the array.
But if you mix them up, your results might shift unexpectedly. ğŸ˜…

ğŸ“˜ **Rule of thumb:**

* Use **`OFFSET()`** when you think in *zero-based indexing* (like most programming languages).
* Use **`ORDINAL()`** when you want *human-style numbering* â€” first = 1, second = 2, etc.


## ğŸ§± Step 1: Create a sample table

```sql
CREATE OR REPLACE TABLE demo.products AS
SELECT 
  1 AS id,
  ['apple', 'banana', 'cherry'] AS fruits
UNION ALL
SELECT 
  2 AS id,
  ['mango', 'kiwi', 'grapes'] AS fruits;
```

âœ… You now have a table with:

| id | fruits                        |
| -- | ----------------------------- |
| 1  | ['apple', 'banana', 'cherry'] |
| 2  | ['mango', 'kiwi', 'grapes']   |

---

## ğŸŒ Step 2: Use `OFFSET()` (0-based index)

```sql
SELECT
  id,
  fruits[OFFSET(0)] AS first_fruit,
  fruits[OFFSET(1)] AS second_fruit
FROM demo.products;
```

ğŸ§  **Explanation:**

* `OFFSET(0)` â†’ first element
* `OFFSET(1)` â†’ second element

âœ… **Output:**

| id | first_fruit | second_fruit |
| -- | ----------- | ------------ |
| 1  | apple       | banana       |
| 2  | mango       | kiwi         |

---

## ğŸ’ Step 3: Use `ORDINAL()` (1-based index)

```sql
SELECT
  id,
  fruits[ORDINAL(1)] AS first_fruit,
  fruits[ORDINAL(2)] AS second_fruit
FROM demo.products;
```

ğŸ§  **Explanation:**

* `ORDINAL(1)` â†’ first element
* `ORDINAL(2)` â†’ second element

âœ… **Output:**

| id | first_fruit | second_fruit |
| -- | ----------- | ------------ |
| 1  | apple       | banana       |
| 2  | mango       | kiwi         |

---

## ğŸš¨ Step 4: See the difference in indexing

If you try this ğŸ‘‡

```sql
SELECT
  id,
  fruits[OFFSET(2)] AS element_offset,
  fruits[ORDINAL(2)] AS element_ordinal
FROM demo.products;
```

âœ… **Output:**

| id | element_offset | element_ordinal |
| -- | -------------- | --------------- |
| 1  | cherry         | banana          |
| 2  | grapes         | kiwi            |

ğŸ¯ Notice the shift:

* `OFFSET(2)` returns the **third** element
* `ORDINAL(2)` returns the **second** element

## ğŸ” TL;DR:

| Function     | Index Starts At | Example      | Returns     |
| ------------ | --------------- | ------------ | ----------- |
| `OFFSET(n)`  | 0               | `OFFSET(0)`  | 1st element |
| `ORDINAL(n)` | 1               | `ORDINAL(1)` | 1st element |

#BigQuery #SQL #DataEngineering #GoogleCloud #Analytics #CloudComputing #Learning #DevOps #Terraform #Engineering

